<?php
/*
 * Copyright 2020 (c) Neo-OOH - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * Written by Valentin Dufois <vdufois@neo-ooh.com>
 *
 * @neo/api - Contract.php
 */

namespace Neo\Models;

use Carbon\Carbon;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasManyThrough;
use Illuminate\Support\Facades\Cache;
use Neo\Modules\Broadcast\Exceptions\InvalidBroadcasterAdapterException;
use Neo\Modules\Broadcast\Models\BroadcasterConnection;
use Neo\Modules\Broadcast\Models\Location;
use Neo\Modules\Broadcast\Services\BroadcasterAdapterFactory;
use Neo\Modules\Broadcast\Services\BroadcasterCapability;
use Neo\Modules\Broadcast\Services\BroadcasterOperator;
use Neo\Modules\Broadcast\Services\BroadcasterReporting;
use Neo\Modules\Broadcast\Services\BroadcasterScheduling;
use Neo\Modules\Broadcast\Services\BroadSign\Models\ReservablePerformance;
use Neo\Modules\Broadcast\Services\Resources\CampaignPerformance;
use Neo\Modules\Broadcast\Services\Resources\ExternalBroadcasterResourceId;
use Spatie\DataTransferObject\Exceptions\UnknownProperties;

/**
 * Class Contract
 *
 * @package Neo\Models
 *
 * @property integer                           $id
 * @property string                            $contract_id // ID of the contract has set by sales (not related to the actual ID
 *           of the contract inside Connect)
 * @property integer                           $external_id
 * @property integer                           $client_id
 * @property integer                           $salesperson_id
 * @property integer                           $advertiser_id
 * @property Carbon                            $start_date
 * @property Carbon                            $end_date
 * @property integer                           $expected_impressions
 * @property integer                           $received_impressions
 * @property integer                           $created_at
 * @property integer                           $updated_at
 *
 * @property Client                            $client
 * @property Collection<ContractFlight>        $flights
 * @property Actor                             $owner
 * @property Collection<ContractBurst>         $bursts
 * @property Collection<ContractReservation>   $reservations
 * @property Collection<ReservablePerformance> $performances
 */
class Contract extends Model {
    protected $table = "contracts";

    protected $fillable = [
        "contract_id",
        "client_id",
        "salesperson_id",
    ];

    protected $dates = [
        "start_date",
        "end_date",
    ];

    protected static function boot() {
        parent::boot(); // TODO: Change the autogenerated stub

        static::deleting(function (Contract $contract) {
            foreach ($contract->bursts as $burst) {
                $burst->delete();
            }
        });
    }

    /*
    |--------------------------------------------------------------------------
    | Relations
    |--------------------------------------------------------------------------
    */

    public function salesperson(): BelongsTo {
        return $this->belongsTo(Actor::class, "salesperson_id", "id");
    }

    public function advertiser(): BelongsTo {
        return $this->belongsTo(Advertiser::class, "advertiser_id", "id");
    }

    public function client(): BelongsTo {
        return $this->belongsTo(Client::class, "client_id", "id");
    }

    public function owner(): BelongsTo {
        return $this->belongsTo(Actor::class, "owner_id", "id");
    }

    public function bursts(): HasMany {
        return $this->hasMany(ContractBurst::class, "contract_id", "id");
    }

    public function reservations(): HasMany {
        return $this->hasMany(ContractReservation::class, "contract_id", "id");
    }

    public function data(): HasMany {
        return $this->hasMany(ContractNetworkData::class, "contract_id", "id");
    }

    public function flights(): HasMany {
        return $this->hasMany(ContractFlight::class, "contract_id", "id")->orderBy("start_date");
    }

    public function screenshots(): HasManyThrough {
        return $this->hasManyThrough(ContractScreenshot::class, ContractBurst::class, 'contract_id', 'burst_id');
    }

    public function validated_screenshots(): HasManyThrough {
        return $this->hasManyThrough(ContractScreenshot::class, ContractBurst::class, 'contract_id', 'burst_id')
                    ->where("is_locked", "=", true);
    }

    /*
    |--------------------------------------------------------------------------
    | External Relations
    |--------------------------------------------------------------------------
    */

    public function getContractPerformancesCacheKey(): string {
        return "contract-" . $this->id . "-performances";
    }

    public function getPerformancesAttribute() {
        return Cache::tags(["contract-performances"])->remember($this->getContractPerformancesCacheKey(), 3600 * 3, function () {
            $reservationsByBroadcaster = $this->reservations->groupBy("broadcaster_id");

            /** @var CampaignPerformance[][] $performances */
            $performances = [];

            /** @var Collection<ContractReservation> $reservations */
            foreach ($reservationsByBroadcaster as $broadcasterId => $reservations) {
                /** @var BroadcasterOperator & BroadcasterReporting $broadcaster */
                $broadcaster = BroadcasterAdapterFactory::makeForBroadcaster($broadcasterId);

                // Make sure the broadcaster supports reporting
                if (!$broadcaster->hasCapability(BroadcasterCapability::Reporting)) {
                    continue;
                }

                $performances[] = $broadcaster->getCampaignsPerformances($reservations->map(fn(ContractReservation $reservation) => $reservation->toResource())
                                                                                      ->toArray());
            }

            return collect(array_merge(...$performances));
        });
    }

    /**
     * List all the reservations of the contracts, with their `locations` property set to the targeted locations
     *
     * @return \Illuminate\Support\Collection<ContractReservation>
     * @throws InvalidBroadcasterAdapterException
     * @throws UnknownProperties
     */
    public function loadReservationsLocations(): \Illuminate\Support\Collection {
        $reservationsByBroadcaster = $this->reservations->groupBy("broadcaster_id");

        /** @var Collection<ContractReservation> $reservations */
        foreach ($reservationsByBroadcaster as $broadcasterId => $reservations) {
            /** @var BroadcasterOperator & BroadcasterScheduling $broadcaster */
            $broadcaster = BroadcasterAdapterFactory::makeForBroadcaster($broadcasterId);

            /** @var BroadcasterConnection $connection */
            $connection = BroadcasterConnection::query()->find($broadcaster->getBroadcasterId());
            $networkIds = $connection->networks()->get()->pluck("id");

            foreach ($this->reservations as $reservation) {
                $externalLocations      = $broadcaster->getCampaignLocations($reservation->toResource());
                $reservation->locations = Location::query()
                                                  ->whereIn("network_id", $networkIds)
                                                  ->whereIn("external_id", array_map(static fn(ExternalBroadcasterResourceId $location) => $location->external_id, $externalLocations))
                                                  ->get();
            }
        }

        return $reservationsByBroadcaster->flatten();
    }
}
